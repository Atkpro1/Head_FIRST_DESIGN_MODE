\documentclass{ctexart}
\def\enter{{\hfill\break}}
\begin{document}
\enter
先说一下为啥Unit没写\enter
因为...\enter
C++没有反射!!!\enter
Vhat the(我一句脏话没说)\enter
PS.Gtest会生成一个新类继承自原来的TestSuite,所以无需反射,但这招我不会\enter
\enter
好了,我们先说模板.\enter
我们知道,现今{100\%}的程序Or函数是与一个图灵机等价的(我只说等价,你也可以用了LISP再把它变成图灵机.)\enter
So,它的行为很固定.你把参数,文件,网络,环境,时钟......都固定,结果就都一样.\enter
那莫不是太无趣了???我们得加点可变的参数.\enter
加什么呢???加一个图灵机做参数吧.改数据参数太无趣了.\enter
不过这个图灵机直接加入参数也不行.\enter
算了,让它成为这个图灵机的一部分吧.\enter
然后???这个图灵机就算运用了"模板方法"\enter
所谓模板方法,就是执行某些行为不确定的函数\enter
等等,所以我每调用一个this的非Final函数都算模板方法???\enter
Sorry,某种意义上,算.\enter
(C++自带Final,233)\enter
\enter
PS.如果你调用的非Final函数是参数,不算模板,不过这算组合,比继承好233\enter
PS2.为啥我觉得模板后面应直接接个策略呢???\enter
\enter
再说迭代器
提到迭代器,不得不说它的原形--指针\enter
OOPS,人都被吓跑了.\enter
我们来看看,指针能干啥?\enter
见Pointer.cpp\enter
指针就是迭代器中最厉害的的,速度最快,支持一切操作.\enter
反正C++泛型支持DuckTyping,指针不是类也不要紧(233)\enter
(所以C++迭代器没有HasNext和Remove,却有些支持向后遍历)\enter
你可以看看C++STL,需要一个集合,就要求给一个开头一个超尾(结尾后一个),还是静态方法\enter
C++为了兼容C指针,费了多少苦心啊.\enter
不过这下就不用操心数组了.反正数组指针C里是一个东西(不懂的去补大学课)\enter
PS.迭代器类型我一般写auto,自动类型推导,毕竟中规中举写实在太长\enter
OOPS,写好长了呢!!!结束吧.\enter
\end{document}
